# Verifying Proofs: Solidity & EVM

SP1 recently added support for verifying proofs for onchain usecases. To see an end-to-end example
of using SP1 for on-chain usecases, refer to the [SP1 Project Template](https://github.com/succinctlabs/sp1-project-template/tree/main).

## Generating a Plonk Bn254 Proof

By default, the proofs generated by SP1 are not verifiable onchain, as they are non-constant size and STARK verification on Ethereum is very expensive. To generate a proof that can be verified onchain, we use performant STARK recursion to combine SP1 shard proofs into a single STARK proof and then wrap that in a SNARK proof. Our `ProverClient` has a function for this called `prove_plonk`. Behind the scenes, this function will first generate a normal SP1 proof, then recursively combine all of them into a single proof using the STARK recursion protocol. Finally, the proof is wrapped in a SNARK proof using PLONK.

**The PLONK Bn254 prover is only guaranteed to work on official releases of SP1.**

To use PLONK proving & verification locally, enable the `plonk` feature flag in the sp1-sdk and ensure that Go >1.22.1 is installed.
```toml
sp1-sdk = { features = ["plonk"] }
```

### Example

```rust,noplayground
{{#include ../../examples/fibonacci/script/bin/plonk_bn254.rs}}
```

You can run the above script with `RUST_LOG=info cargo run --bin plonk_bn254 --release` in `examples/fibonacci/script`.

## Install SP1 Contracts

https://github.com/succinctlabs/sp1-contracts/blob/f74ad2963bbb09ac283af8d10152765ab8e07111/README.md?plain=1#L1-L34